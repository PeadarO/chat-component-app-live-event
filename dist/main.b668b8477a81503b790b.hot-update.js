webpackHotUpdate("main",{

/***/ "./node_modules/react-form/dist/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/react-form/dist/index.es.js ***!
  \**************************************************/
/*! exports provided: splitFormProps, useField, useForm, useFormContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitFormProps\", function() { return splitFormProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useField\", function() { return useField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useForm\", function() { return useForm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFormContext\", function() { return useFormContext; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction useAsyncDebounce(defaultFn) {\n  var defaultWait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var debounceRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef({});\n  debounceRef.current.defaultFn = defaultFn;\n  debounceRef.current.defaultWait = defaultWait;\n  var debounce = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(async function () {\n    var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : debounceRef.current.defaultFn;\n    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : debounceRef.current.defaultWait;\n\n    if (!debounceRef.current.promise) {\n      debounceRef.current.promise = new Promise(function (resolve) {\n        debounceRef.current.resolve = resolve;\n      });\n    }\n\n    if (debounceRef.current.timeout) {\n      clearTimeout(debounceRef.current.timeout);\n    }\n\n    debounceRef.current.timeout = setTimeout(async function () {\n      delete debounceRef.current.timeout;\n\n      try {\n        debounceRef.current.resolve(await fn());\n      } catch (err) {\n        debounceRef.current.reject(err);\n      } finally {\n        delete debounceRef.current.promise;\n      }\n    }, wait);\n    return debounceRef.current.promise;\n  }, []);\n  return debounce;\n}\n\nvar formContext = react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext();\n\nfunction FormContextProvider(_ref) {\n  var value = _ref.value,\n      children = _ref.children;\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(formContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction useFormContext(manualFormContext) {\n  var formApi = react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(formContext);\n\n  if (manualFormContext) {\n    return manualFormContext;\n  }\n\n  if (!formApi) {\n    throw new Error(\"You are trying to use the form API outside of a form!\");\n  }\n\n  return formApi;\n}\n\nfunction useFormElement(contextValue) {\n  var FormRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef();\n  var FormApiRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef();\n  FormApiRef.current = contextValue; // Create a new form element\n\n  if (!FormRef.current) {\n    FormRef.current = function Form(_ref) {\n      var children = _ref.children,\n          noFormElement = _ref.noFormElement,\n          rest = _objectWithoutProperties(_ref, [\"children\", \"noFormElement\"]);\n\n      var _FormApiRef$current = FormApiRef.current,\n          handleSubmit = _FormApiRef$current.handleSubmit,\n          isSubmitting = _FormApiRef$current.meta.isSubmitting,\n          debugForm = _FormApiRef$current.debugForm;\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormContextProvider, {\n        value: FormApiRef.current\n      }, noFormElement ? children : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"form\", _extends({\n        onSubmit: handleSubmit,\n        disabled: isSubmitting\n      }, rest), children, debugForm ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", {\n        style: {\n          margin: '2rem 0'\n        }\n      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", {\n        style: {\n          fontWeight: 'bolder'\n        }\n      }, \"Form State\"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"pre\", null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"code\", null, JSON.stringify(_objectSpread({}, FormApiRef.current, {\n        formContext: undefined\n      }), safeStringifyReplace(new Set()), 2)))) : null));\n    };\n  } // Return the form element\n\n\n  return FormRef.current;\n}\n\nfunction safeStringifyReplace(set) {\n  return function (key, value) {\n    if (_typeof(value) === 'object' || Array.isArray(value)) {\n      if (set.has(value)) {\n        return '(circular value)';\n      }\n\n      set.add(value);\n    }\n\n    return typeof value === 'function' ? undefined : value;\n  };\n}\n\nfunction splitFormProps(_ref) {\n  var field = _ref.field,\n      defaultValue = _ref.defaultValue,\n      defaultIsTouched = _ref.defaultIsTouched,\n      defaultError = _ref.defaultError,\n      defaultMeta = _ref.defaultMeta,\n      validatePristine = _ref.validatePristine,\n      validate = _ref.validate,\n      onSubmit = _ref.onSubmit,\n      defaultValues = _ref.defaultValues,\n      filterValue = _ref.filterValue,\n      debugForm = _ref.debugForm,\n      rest = _objectWithoutProperties(_ref, [\"field\", \"defaultValue\", \"defaultIsTouched\", \"defaultError\", \"defaultMeta\", \"validatePristine\", \"validate\", \"onSubmit\", \"defaultValues\", \"filterValue\", \"debugForm\"]);\n\n  return [field, {\n    defaultValue: defaultValue,\n    defaultIsTouched: defaultIsTouched,\n    defaultError: defaultError,\n    defaultMeta: defaultMeta,\n    validatePristine: validatePristine,\n    validate: validate,\n    onSubmit: onSubmit,\n    defaultValues: defaultValues,\n    filterValue: filterValue,\n    debugForm: debugForm\n  }, rest];\n} // Utils\n\n\nfunction getBy(obj, path) {\n  if (!path) {\n    throw new Error('A path string is required to use getBy');\n  }\n\n  var pathArray = makePathArray(path);\n  var pathObj = pathArray;\n  return pathObj.reduce(function (current, pathPart) {\n    if (typeof current !== 'undefined') {\n      return current[pathPart];\n    }\n\n    return undefined;\n  }, obj);\n}\n\nfunction setBy(obj, path, updater) {\n  path = makePathArray(path);\n\n  function doSet(parent) {\n    if (!path.length) {\n      return typeof updater === 'function' ? updater(parent) : updater;\n    }\n\n    var key = path.shift();\n\n    if (typeof key === 'string') {\n      if (_typeof(parent) === 'object') {\n        return _objectSpread({}, parent, _defineProperty({}, key, doSet(parent[key])));\n      }\n\n      return _defineProperty({}, key, doSet());\n    }\n\n    if (typeof key === 'number') {\n      if (Array.isArray(parent)) {\n        var prefix = parent.slice(0, key);\n        return [].concat(_toConsumableArray(prefix.length ? prefix : new Array(key)), [doSet(parent[key])], _toConsumableArray(parent.slice(key + 1)));\n      }\n\n      return [].concat(_toConsumableArray(new Array(key)), [doSet()]);\n    }\n\n    throw new Error('Uh oh!');\n  }\n\n  return doSet(obj);\n}\n\nfunction getFieldID(str) {\n  return makePathArray(str).join('_');\n}\n\nvar reFindNumbers0 = /^(\\d*)$/gm;\nvar reFindNumbers1 = /\\.(\\d*)\\./gm;\nvar reFindNumbers2 = /^(\\d*)\\./gm;\nvar reFindNumbers3 = /\\.(\\d*$)/gm;\nvar reFindMultiplePeriods = /\\.{2,}/gm;\n\nfunction makePathArray(str) {\n  return str.replace('[', '.').replace(']', '').replace(reFindNumbers0, '__int__$1').replace(reFindNumbers1, '.__int__$1.').replace(reFindNumbers2, '__int__$1.').replace(reFindNumbers3, '.__int__$1').replace(reFindMultiplePeriods, '.').split('.').map(function (d) {\n    if (d.indexOf('__int__') === 0) {\n      return parseInt(d.substring('__int__'.length), 10);\n    }\n\n    return d;\n  });\n}\n\nfunction loopObject(obj, fn, callback) {\n  Object.keys(obj).forEach(function (key) {\n    callback(fn(obj[key], key), key);\n  });\n}\n\nfunction someObject(obj, fn) {\n  var found = false;\n  loopObject(obj, fn, function (result, key) {\n    if (found) {\n      return;\n    }\n\n    if (result) {\n      found = true;\n    }\n  });\n  return found;\n}\n\nvar defaultDefaultValue = {};\n\nfunction makeState(decor) {\n  return _objectSpread({\n    meta: {\n      isSubmitting: false,\n      isTouched: false,\n      isSubmitted: false,\n      submissionAttempts: 0\n    },\n    __fieldMeta: {}\n  }, decor);\n}\n\nfunction useForm() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      onSubmit = _ref.onSubmit,\n      _ref$defaultValues = _ref.defaultValues,\n      defaultValues = _ref$defaultValues === void 0 ? defaultDefaultValue : _ref$defaultValues,\n      validate = _ref.validate,\n      validatePristine = _ref.validatePristine,\n      debugForm = _ref.debugForm;\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(function () {\n    return makeState({\n      values: defaultValues\n    });\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      _React$useState2$ = _React$useState2[0],\n      values = _React$useState2$.values,\n      meta = _React$useState2$.meta,\n      __fieldMeta = _React$useState2$.__fieldMeta,\n      setState = _React$useState2[1];\n\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0___default.a.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      shouldResubmit = _React$useState4[0],\n      setShouldResubmit = _React$useState4[1];\n\n  var apiRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef();\n  var metaRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef({});\n\n  var __fieldMetaRefsRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef({}); // Keep validate up to date with the latest version\n\n\n  metaRef.current.validate = validate;\n  var fieldsAreValidating = someObject(__fieldMeta, function (field) {\n    return field && field.isValidating;\n  });\n  var fieldsAreValid = !someObject(__fieldMeta, function (field) {\n    return field && field.error;\n  }); // Can we submit this form?\n\n  var isValid = !fieldsAreValidating && fieldsAreValid && !meta.error;\n  var canSubmit = isValid && !meta.isValidating && !meta.isSubmitting; // Decorate form meta\n\n  meta = react__WEBPACK_IMPORTED_MODULE_0___default.a.useMemo(function () {\n    return _objectSpread({}, meta, {\n      fieldsAreValidating: fieldsAreValidating,\n      fieldsAreValid: fieldsAreValid,\n      isValid: isValid,\n      canSubmit: canSubmit\n    });\n  }, [meta, fieldsAreValidating, fieldsAreValid, isValid, canSubmit]); // We want the apiRef to change every time state updates\n\n  var api = react__WEBPACK_IMPORTED_MODULE_0___default.a.useMemo(function () {\n    return {\n      values: values,\n      meta: meta,\n      __fieldMeta: __fieldMeta,\n      debugForm: debugForm\n    };\n  }, [debugForm, __fieldMeta, meta, values]); // Keep the apiRef up to date with the latest version of the api\n\n  apiRef.current = api;\n  var reset = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function () {\n    setState(function () {\n      return makeState({\n        values: defaultValues\n      });\n    });\n  }, [defaultValues, setState]); // On submit\n\n  var handleSubmit = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(async function () {\n    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (e.persist) e.persist();\n    if (e.preventDefault) e.preventDefault(); // This lets sub-forms with form elements (despite them being invalid HTML)\n    // handle submissions without triggering parent forms\n\n    if (e.__handled) {\n      return;\n    }\n\n    e.__handled = true; // Don't let invalid forms submit\n\n    if (!apiRef.current.meta.isValid) {\n      // If the form can't submit, let's trigger all of the fields\n      // to be touched. Thus, their validations will run\n      apiRef.current.setMeta({\n        isSubmitting: false\n      });\n      return;\n    }\n\n    apiRef.current.setMeta({\n      isSubmitting: true\n    });\n    var needsResubmit = false;\n    var fieldValidationPromises = [];\n    Object.keys(apiRef.current.__fieldMetaRefs).forEach(function (key) {\n      var fieldMeta = apiRef.current.__fieldMetaRefs[key].current;\n      Object.keys(fieldMeta.instanceRefs).forEach(function (key) {\n        var fieldInstance = fieldMeta.instanceRefs[key].current; // If any fields are not touched\n\n        if (!fieldInstance.meta.isTouched) {\n          // Mark them as touched\n          fieldInstance.setMeta({\n            isTouched: true\n          }); // Likewise, if they need validation\n\n          if (fieldInstance.__validate) {\n            // Run their validation and keep track of the\n            // promise\n            fieldValidationPromises.push(fieldInstance.runValidation());\n          }\n        }\n      });\n    }); // If any validation needed to be run\n\n    if (fieldValidationPromises.length) {\n      // Mark for resubmission\n      needsResubmit = true;\n    }\n\n    if (!apiRef.current.meta.isTouched) {\n      // Mark for resubmission\n      needsResubmit = true; // Mark the form as touched\n\n      apiRef.current.setMeta(function (old) {\n        return _objectSpread({}, old, {\n          isTouched: true\n        });\n      });\n    }\n\n    if (needsResubmit) {\n      // Wait for any field validations to complete\n      await Promise.all(fieldValidationPromises); // Be sure to run validation for the form\n      // and wait for it to complete\n\n      await apiRef.current.runValidation(); // Then rerun the submission attempt\n\n      e.__handled = false;\n      setShouldResubmit(e || true); // Do not continue\n\n      return;\n    }\n\n    apiRef.current.setMeta(function (old) {\n      return _objectSpread({}, old, {\n        // Submittion attempts mark the form as not submitted\n        isSubmitted: false,\n        // Count submission attempts\n        submissionAttempts: old.submissionAttempts + 1\n      });\n    });\n\n    try {\n      // Run the submit code\n      await apiRef.current.onSubmit(apiRef.current.values, apiRef.current);\n      apiRef.current.setMeta({\n        isSubmitted: true\n      });\n    } catch (err) {\n      throw err;\n    } finally {\n      apiRef.current.setMeta({\n        isSubmitting: false\n      });\n    }\n  }, []); // Create a debounce for this field hook instance (not all instances)\n\n  var debounce = useAsyncDebounce();\n  var setMeta = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (updater) {\n    setState(function (old) {\n      return _objectSpread({}, old, {\n        meta: typeof updater === 'function' ? updater(old.meta) : _objectSpread({}, old.meta, updater)\n      });\n    });\n  }, [setState]);\n  var runValidation = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function () {\n    if (!metaRef.current.validate) {\n      return;\n    }\n\n    apiRef.current.setMeta({\n      isValidating: true\n    }); // Use the validationCount for all field instances to\n    // track freshness of the validation\n\n    var id = (metaRef.current.validationCount || 0) + 1;\n    metaRef.current.validationCount = id;\n\n    var checkLatest = function checkLatest() {\n      return id === metaRef.current.validationCount;\n    };\n\n    if (!metaRef.current.validationPromise) {\n      metaRef.current.validationPromise = new Promise(function (resolve, reject) {\n        metaRef.current.validationResolve = resolve;\n        metaRef.current.validationReject = reject;\n      });\n    }\n\n    var doValidation = async function doValidation() {\n      try {\n        var error = await metaRef.current.validate(apiRef.current.values, apiRef.current);\n\n        if (checkLatest()) {\n          apiRef.current.setMeta({\n            isValidating: false\n          });\n\n          if (typeof error !== 'undefined') {\n            if (error) {\n              if (typeof error === 'string') {\n                apiRef.current.setMeta({\n                  error: error\n                });\n              }\n            } else {\n              apiRef.current.setMeta({\n                error: null\n              });\n            }\n          }\n\n          metaRef.current.validationResolve();\n        }\n      } catch (err) {\n        if (checkLatest()) {\n          metaRef.current.validationReject(err);\n        }\n      } finally {\n        delete metaRef.current.validationPromise;\n      }\n    };\n\n    doValidation();\n    return metaRef.current.validationPromise;\n  }, []);\n  var getFieldValue = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field) {\n    return getBy(apiRef.current.values, field);\n  }, []);\n  var getFieldMeta = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field) {\n    var fieldID = getFieldID(field);\n    return apiRef.current.__fieldMeta[fieldID];\n  }, []);\n\n  var __getFieldMetaRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field) {\n    var fieldID = getFieldID(field);\n\n    if (!apiRef.current.__fieldMetaRefs[fieldID]) {\n      apiRef.current.__fieldMetaRefs[fieldID] = {\n        current: {\n          instanceRefs: {}\n        }\n      };\n    }\n\n    return apiRef.current.__fieldMetaRefs[fieldID];\n  }, []);\n\n  var setFieldMeta = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field, updater) {\n    var fieldID = getFieldID(field);\n    setState(function (old) {\n      var newFieldMeta = typeof updater === 'function' ? updater(old.__fieldMeta[fieldID]) : _objectSpread({}, old.__fieldMeta[fieldID], updater);\n      return _objectSpread({}, old, {\n        // Any errors in fields should visually stop\n        // form.isSubmitting\n        meta: newFieldMeta && newFieldMeta.error ? _objectSpread({}, old.meta, {\n          isSubmitting: false\n        }) : old.meta,\n        __fieldMeta: _objectSpread({}, old.__fieldMeta, _defineProperty({}, fieldID, newFieldMeta))\n      });\n    });\n  }, [setState]);\n  var setFieldValue = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field, updater) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$isTouched = _ref2.isTouched,\n        isTouched = _ref2$isTouched === void 0 ? true : _ref2$isTouched;\n\n    var fieldInstances = apiRef.current.__getFieldInstances(field);\n\n    setState(function (old) {\n      var newValue = typeof updater === 'function' ? updater(getBy(old.values, field)) : updater;\n      fieldInstances.forEach(function (instance) {\n        if (instance.current.__filterValue) {\n          newValue = instance.current.__filterValue(newValue, apiRef.current);\n        }\n      });\n      return _objectSpread({}, old, {\n        values: setBy(old.values, field, newValue)\n      });\n    });\n\n    if (isTouched) {\n      apiRef.current.setFieldMeta(field, {\n        isTouched: true\n      });\n      apiRef.current.setMeta({\n        isTouched: true\n      });\n    }\n  }, [setState]);\n\n  var __getFieldInstances = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field) {\n    var __metaRef = apiRef.current.__getFieldMetaRef(field);\n\n    return Object.keys(__metaRef.current.instanceRefs).map(function (key) {\n      return __metaRef.current.instanceRefs[key];\n    });\n  }, []);\n\n  var pushFieldValue = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field, value, options) {\n    apiRef.current.setFieldValue(field, function (old) {\n      return [].concat(_toConsumableArray(Array.isArray(old) ? old : []), [value]);\n    }, options);\n  }, []);\n  var insertFieldValue = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field, index, value, options) {\n    apiRef.current.setFieldValue(field, function (old) {\n      if (Array.isArray(old)) {\n        return old.map(function (d, i) {\n          return i === index ? value : d;\n        });\n      } else {\n        throw Error(\"Cannot insert a field value into a non-array field. Check that this field's existing value is an array: \".concat(field, \".\"));\n      }\n    }, options);\n  }, []);\n  var removeFieldValue = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (field, index, options) {\n    apiRef.current.setFieldValue(field, function (old) {\n      if (Array.isArray(old)) {\n        return old.filter(function (d, i) {\n          return i !== index;\n        });\n      } else {\n        throw Error(\"Cannot remove a field value from a non-array field. Check that this field's existing value is an array: \".concat(field, \".\"));\n      }\n    }, options);\n  }, []);\n  var swapFieldValues = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (path, index1, index2) {\n    setState(function (old) {\n      var old1 = getBy(old.values, [path, index1]);\n      var old2 = getBy(old.values, [path, index2]);\n      var values = setBy(old.values, [path, index1], old2);\n      values = setBy(values, [path, index2], old1);\n      return _objectSpread({}, old, {\n        values: values\n      });\n    });\n  }, [setState]);\n  var setValues = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (values) {\n    setState(function (old) {\n      return _objectSpread({}, old, {\n        values: values\n      });\n    });\n  }, [setState]); // Create the Form element if necessary\n\n  var Form = useFormElement(api);\n  Object.assign(api, {\n    __fieldMetaRefs: __fieldMetaRefsRef.current,\n    onSubmit: onSubmit,\n    reset: reset,\n    handleSubmit: handleSubmit,\n    debounce: debounce,\n    setMeta: setMeta,\n    runValidation: runValidation,\n    getFieldValue: getFieldValue,\n    getFieldMeta: getFieldMeta,\n    __getFieldMetaRef: __getFieldMetaRef,\n    setFieldMeta: setFieldMeta,\n    setFieldValue: setFieldValue,\n    __getFieldInstances: __getFieldInstances,\n    pushFieldValue: pushFieldValue,\n    insertFieldValue: insertFieldValue,\n    removeFieldValue: removeFieldValue,\n    swapFieldValues: swapFieldValues,\n    setValues: setValues,\n    Form: Form,\n    formContext: api\n  }); // If shouldResubmit is true, do yo thang\n\n  react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {\n    if (shouldResubmit) {\n      handleSubmit(shouldResubmit);\n      setShouldResubmit(false);\n    }\n  }, [handleSubmit, shouldResubmit]); // When the form gets dirty and when the value changes\n  // validate\n\n  react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {\n    if (!validatePristine && !meta.isTouched) {\n      return;\n    }\n\n    apiRef.current.runValidation(values);\n  }, [meta.isTouched, validatePristine, values]); // When defaultValues update, set them\n\n  react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {\n    if (defaultValues !== apiRef.current.values) {\n      setState(function (old) {\n        return _objectSpread({}, old, {\n          values: defaultValues\n        });\n      });\n    }\n  }, [defaultValues, setState]); // Return the root form and the Form component to the hook user\n\n  return apiRef.current;\n}\n\nfunction useFieldScope(contextValue) {\n  var FieldScopeRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef();\n  var FieldScopeApiRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef();\n  FieldScopeApiRef.current = contextValue; // Create a new form element\n\n  if (!FieldScopeRef.current) {\n    FieldScopeRef.current = function Field(_ref) {\n      var children = _ref.children;\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FormContextProvider, {\n        value: FieldScopeApiRef.current\n      }, children);\n    };\n  }\n\n  return FieldScopeRef.current;\n}\n\nvar uid = 0;\nvar methodMap = ['setFieldValue', 'setFieldMeta', 'pushFieldValue', 'insertFieldValue', 'removeFieldValue', 'swapFieldValues'];\nvar defaultDefaultMeta = {\n  error: null,\n  isTouched: false,\n  isValidating: false\n};\n\nfunction useField(fieldName) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      defaultValue = _ref.defaultValue,\n      _ref$defaultIsTouched = _ref.defaultIsTouched,\n      defaultIsTouched = _ref$defaultIsTouched === void 0 ? false : _ref$defaultIsTouched,\n      _ref$defaultError = _ref.defaultError,\n      defaultError = _ref$defaultError === void 0 ? null : _ref$defaultError,\n      _ref$defaultMeta = _ref.defaultMeta,\n      defaultMeta = _ref$defaultMeta === void 0 ? defaultDefaultMeta : _ref$defaultMeta,\n      validatePristine = _ref.validatePristine,\n      validate = _ref.validate,\n      filterValue = _ref.filterValue,\n      manualFormContext = _ref.formContext;\n\n  if (!fieldName) {\n    throw new Error(\"useField: A field is required to use this hook. eg, useField('myField', options)\");\n  }\n\n  var formApiRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef();\n  var fieldApiRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef({});\n  var formApi = useFormContext(manualFormContext);\n  var instanceIDRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.useRef(uid++);\n  var instanceID = instanceIDRef.current; // Support field prefixing from FieldScope\n\n  var fieldPrefix = '';\n\n  if (formApi.fieldName) {\n    fieldPrefix = \"\".concat(formApi.fieldName, \".\");\n    formApi = formApi.form;\n  }\n\n  fieldName = fieldPrefix + fieldName; // Create a debounce for this field hook instance (not all instances)\n\n  var debounce = useAsyncDebounce(); // An escape hatch for accessing latest formAPI\n\n  formApiRef.current = formApi; // Get the field value, meta, and metaRef\n\n  var preValue = formApi.getFieldValue(fieldName);\n  var preMeta = formApi.getFieldMeta(fieldName);\n\n  var __metaRef = formApi.__getFieldMetaRef(fieldName); // Handle default value\n\n\n  var value = react__WEBPACK_IMPORTED_MODULE_0___default.a.useMemo(function () {\n    return typeof preValue === 'undefined' && typeof defaultValue !== 'undefined' ? defaultValue : preValue;\n  }, [defaultValue, preValue]); // Handle default meta\n\n  var meta = react__WEBPACK_IMPORTED_MODULE_0___default.a.useMemo(function () {\n    return typeof preMeta === 'undefined' ? _objectSpread({}, defaultMeta, {\n      error: defaultError,\n      isTouched: defaultIsTouched\n    }) : preMeta;\n  }, [defaultError, defaultMeta, defaultIsTouched, preMeta]); // Create the fieldApi\n\n  var fieldApi = react__WEBPACK_IMPORTED_MODULE_0___default.a.useMemo(function () {\n    return {\n      value: value,\n      meta: meta,\n      form: formApi,\n      fieldName: fieldName\n    };\n  }, [fieldName, formApi, meta, value]); // Keep the fieldApiRef up to date\n\n  fieldApiRef.current = fieldApi;\n  fieldApiRef.current.__filterValue = filterValue;\n  fieldApiRef.current.__validate = validate; // Let's scope some field-level methods for convenience\n\n  var _methodMap$map = methodMap.map(function (d) {\n    // Since this array is stable and always the same, we can disable\n    // the react-hooks linter here:\n    // eslint-disable-next-line\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function () {\n      var _formApiRef$current;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_formApiRef$current = formApiRef.current)[d].apply(_formApiRef$current, [fieldName].concat(args));\n    }, // eslint-disable-next-line\n    [fieldName]);\n  }),\n      _methodMap$map2 = _slicedToArray(_methodMap$map, 6),\n      setValue = _methodMap$map2[0],\n      setMeta = _methodMap$map2[1],\n      pushValue = _methodMap$map2[2],\n      insertValue = _methodMap$map2[3],\n      removeValue = _methodMap$map2[4],\n      swapValues = _methodMap$map2[5]; // Let's scope some field-level methods for convenience\n\n\n  var _methodMap$map3 = methodMap.map(function (d) {\n    // Since this array is stable and always the same, we can disable\n    // the react-hooks linter here:\n    // eslint-disable-next-line\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function (subField) {\n      var _formApiRef$current2;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_formApiRef$current2 = formApiRef.current)[d].apply(_formApiRef$current2, [\"\".concat(fieldName, \".\").concat(subField)].concat(args));\n    }, // eslint-disable-next-line\n    [fieldName]);\n  }),\n      _methodMap$map4 = _slicedToArray(_methodMap$map3, 6),\n      setFieldValue = _methodMap$map4[0],\n      setFieldMeta = _methodMap$map4[1],\n      pushFieldValue = _methodMap$map4[2],\n      insertFieldValue = _methodMap$map4[3],\n      removeFieldValue = _methodMap$map4[4],\n      swapFieldValues = _methodMap$map4[5];\n\n  var runValidation = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(async function () {\n    if (!fieldApiRef.current.__validate) {\n      return;\n    }\n\n    setMeta({\n      isValidating: true\n    }); // Use the validationCount for all field instances to\n    // track freshness of the validation\n\n    var id = (__metaRef.current.validationCount || 0) + 1;\n    __metaRef.current.validationCount = id;\n\n    var checkLatest = function checkLatest() {\n      return id === __metaRef.current.validationCount;\n    };\n\n    if (!__metaRef.current.validationPromise) {\n      __metaRef.current.validationPromise = new Promise(function (resolve, reject) {\n        __metaRef.current.validationResolve = resolve;\n        __metaRef.current.validationReject = reject;\n      });\n    }\n\n    var doValidate = async function doValidate() {\n      try {\n        var error = await fieldApiRef.current.__validate(fieldApiRef.current.value, fieldApiRef.current);\n\n        if (checkLatest()) {\n          setMeta({\n            isValidating: false\n          });\n\n          if (typeof error !== 'undefined') {\n            if (error) {\n              if (typeof error === 'string') {\n                setMeta({\n                  error: error\n                });\n              }\n            } else {\n              setMeta({\n                error: null\n              });\n            }\n          }\n\n          __metaRef.current.validationResolve();\n        }\n      } catch (error) {\n        if (checkLatest()) {\n          __metaRef.current.validationReject(error);\n\n          throw error;\n        }\n      } finally {\n        if (checkLatest()) {\n          setMeta({\n            isValidating: false\n          });\n          delete __metaRef.current.validationPromise;\n        }\n      }\n    };\n\n    doValidate();\n    return __metaRef.current.validationPromise;\n  }, [__metaRef, setMeta]);\n  var getInputProps = react__WEBPACK_IMPORTED_MODULE_0___default.a.useCallback(function () {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _onChange = _ref2.onChange,\n        _onBlur = _ref2.onBlur,\n        rest = _objectWithoutProperties(_ref2, [\"onChange\", \"onBlur\"]);\n\n    return _objectSpread({\n      value: value,\n      onChange: function onChange(e) {\n        setValue(e.target.value);\n\n        if (_onChange) {\n          _onChange(e);\n        }\n      },\n      onBlur: function onBlur(e) {\n        setMeta({\n          isTouched: true\n        });\n\n        if (_onBlur) {\n          _onBlur(e);\n        }\n      }\n    }, rest);\n  }, [setMeta, setValue, value]);\n  var FieldScope = useFieldScope(fieldApi); // Fill in the rest of the fieldApi\n\n  Object.assign(fieldApi, {\n    __metaRef: __metaRef,\n    setValue: setValue,\n    setMeta: setMeta,\n    pushValue: pushValue,\n    insertValue: insertValue,\n    removeValue: removeValue,\n    swapValues: swapValues,\n    setFieldValue: setFieldValue,\n    setFieldMeta: setFieldMeta,\n    pushFieldValue: pushFieldValue,\n    insertFieldValue: insertFieldValue,\n    removeFieldValue: removeFieldValue,\n    swapFieldValues: swapFieldValues,\n    debounce: debounce,\n    runValidation: runValidation,\n    getInputProps: getInputProps,\n    FieldScope: FieldScope\n  });\n  react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {\n    var _formApiRef$current$_ = formApiRef.current.__getFieldMetaRef(fieldName),\n        meta = _formApiRef$current$_.current;\n\n    meta.instanceRefs = meta.instanceRefs || {};\n    meta.instanceRefs[instanceID] = fieldApiRef;\n    var fieldID = getFieldID(fieldName);\n    return function () {\n      delete meta.instanceRefs[instanceID];\n\n      if (!Object.keys(meta.instanceRefs).length) {\n        fieldApiRef.current.setMeta(function () {\n          return undefined;\n        });\n        delete formApiRef.current.__fieldMetaRefs[fieldID];\n      }\n    };\n  }, [fieldName, instanceID]); // The default value effect handler\n\n  react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {\n    if (typeof preValue === 'undefined' && typeof value !== 'undefined') {\n      setValue(value, {\n        isTouched: false\n      });\n    }\n  }, [preValue, setValue, value]); // The default meta effect handler\n\n  react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {\n    if (typeof preMeta === 'undefined' && typeof meta !== 'undefined') {\n      setMeta(meta);\n    }\n  }, [fieldName, meta, preMeta, setMeta, setValue, value]); // When the form gets dirty and when the value changes, run the validation\n\n  react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {\n    if (!validatePristine && !meta.isTouched) {\n      return;\n    }\n\n    try {\n      runValidation(value);\n    } catch (err) {\n      console.error('An error occurred during validation', err);\n    }\n  }, [meta.isTouched, runValidation, validatePristine, value]);\n  return fieldApiRef.current;\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/react-form/dist/index.es.js?");

/***/ }),

/***/ "./src/components/LiveFeedPanel/LiveFeedPanel.tsx":
/*!********************************************************!*\
  !*** ./src/components/LiveFeedPanel/LiveFeedPanel.tsx ***!
  \********************************************************/
/*! exports provided: LiveFeedPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiveFeedPanel\", function() { return LiveFeedPanel; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_jitsi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-jitsi */ \"./node_modules/react-jitsi/dist/react-jitsi.esm.js\");\n/* harmony import */ var react_form__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-form */ \"./node_modules/react-form/dist/index.es.js\");\n/* harmony import */ var _LiveFeedPanel_styles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LiveFeedPanel.styles */ \"./src/components/LiveFeedPanel/LiveFeedPanel.styles.tsx\");\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n\n\n\nvar theme = {\n  main: \"mediumseagreen\"\n};\nvar LiveFeedPanel = function LiveFeedPanel(props) {\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"useState\"])('Event-00000-00000'),\n      _useState2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_useState, 2),\n      displayName = _useState2[0],\n      setDisplayName = _useState2[1];\n\n  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"useState\"])('Event-Location-00000-00001'),\n      _useState4 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_useState3, 2),\n      roomName = _useState4[0],\n      setRoomName = _useState4[1];\n\n  var _useState5 = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"useState\"])(''),\n      _useState6 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_useState5, 2),\n      password = _useState6[0],\n      setPassword = _useState6[1];\n\n  var _useState7 = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"useState\"])({}),\n      _useState8 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_useState7, 2),\n      loader = _useState8[0],\n      setLoader = _useState8[1];\n\n  var _useState9 = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"useState\"])(false),\n      _useState10 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_useState9, 2),\n      onCall = _useState10[0],\n      setOnCall = _useState10[1];\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(_LiveFeedPanel_styles__WEBPACK_IMPORTED_MODULE_5__[\"LiveFeedPanelWrapper\"], null, onCall ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_jitsi__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n    roomName: roomName,\n    displayName: displayName //password={password}\n    //loadingComponent={loader}\n    ,\n    containerStyle: {\n      width: '100%',\n      height: '100%',\n      //display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_2___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Form, null)));\n};\nvar InputField = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef(function (props, ref) {\n  // Let's use splitFormProps to get form-specific props\n  var _splitFormProps = Object(react_form__WEBPACK_IMPORTED_MODULE_4__[\"splitFormProps\"])(props),\n      _splitFormProps2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_splitFormProps, 3),\n      field = _splitFormProps2[0],\n      fieldOptions = _splitFormProps2[1],\n      rest = _splitFormProps2[2]; // Use the useField hook with a field and field options\n  // to access field state\n\n\n  var _useField = Object(react_form__WEBPACK_IMPORTED_MODULE_4__[\"useField\"])(field, fieldOptions),\n      _useField$meta = _useField.meta,\n      error = _useField$meta.error,\n      isTouched = _useField$meta.isTouched,\n      isValidating = _useField$meta.isValidating,\n      getInputProps = _useField.getInputProps; // Build the field\n\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_2___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\"input\", getInputProps(_objectSpread({\n    ref: ref\n  }, rest))), \" \", isValidating ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\"em\", null, \"Validating...\") : isTouched && error ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(\"em\", null, error) : null);\n});\n\n//# sourceURL=webpack:///./src/components/LiveFeedPanel/LiveFeedPanel.tsx?");

/***/ })

})